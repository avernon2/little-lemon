import React, { useMemo, useState, useCallback } from 'react';
import {
    Autocomplete,
    Box,
    TextField,
    MenuItem,
    Select,
    FormControl,
    InputLabel,
    SelectChangeEvent,
    Typography
} from '@mui/material';
import { DataGrid, GridColDef, GridSortModel, GridPaginationModel } from '@mui/x-data-grid';

type AggregateType = 'sum' | 'average' | 'count';

interface DataItem {
    [key: string]: number | string;
}

interface Column {
    key: string;
    label: string;
}

interface PivotTableProps<T extends DataItem> {
    data: T[];
    defaultColumns?: Column[];
    aggregate?: AggregateType;
    heading?: string; // Add heading prop
}

const PivotTable = <T extends DataItem>({
    data,
    defaultColumns = [],
    aggregate = 'count',
    heading // Destructure heading prop
}: PivotTableProps<T>) => {
    const [columns, setColumns] = useState<Column[]>(defaultColumns);
    const [sortModel, setSortModel] = useState<GridSortModel>([]);
    const [page, setPage] = useState(0);
    const [pageSize, setPageSize] = useState(100);
    const [selectedAggregate, setSelectedAggregate] = useState<AggregateType>(aggregate);

    const availableColumns = useMemo(() => {
        if (data.length === 0) return [];
        return Object.keys(data[0]).map(key => ({ key, label: key }));
    }, [data]);

    const calculateAggregateValue = useCallback((items: T[], valueCol: Column): number => {
        switch (selectedAggregate) {
            case 'average': {
                const sum = items.reduce((acc, item) => acc + (Number(item[valueCol.key]) || 0), 0);
                return items.length > 0 ? sum / items.length : 0;
            }
            case 'count':
                return items.length;
            case 'sum':
            default:
                return items.reduce((acc, item) => acc + (Number(item[valueCol.key]) || 0), 0);
        }
    }, [selectedAggregate]);

    const pivotData = useMemo(() => {
        if (columns.length === 0) return [];

        const groupedData: { [key: string]: T[] } = {};

        data.forEach((item) => {
            const rowKey = columns.map(col => String(item[col.key])).join('-');
            groupedData[rowKey] = groupedData[rowKey] || [];
            groupedData[rowKey].push(item);
        });

        return Object.entries(groupedData).map(([rowKey, items], index) => {
            const result: DataItem = { id: index };

            // Set row values
            rowKey.split('-').forEach((value, index) => {
                result[columns[index].key] = value;
            });

            // Calculate aggregate
            result['Total'] = calculateAggregateValue(items, { key: 'Revenue', label: 'Revenue' });

            return result;
        });
    }, [data, columns, calculateAggregateValue]);

    const sortedAndFilteredData = useMemo(() => {
        const result = [...pivotData];

        // Apply sorting
        if (sortModel.length > 0) {
            const { field, sort } = sortModel[0];
            result.sort((a, b) => {
                const aVal = a[field];
                const bVal = b[field];
                const multiplier = sort === 'asc' ? 1 : -1;
                return aVal < bVal ? -multiplier : aVal > bVal ? multiplier : 0;
            });
        }

        return result;
    }, [pivotData, sortModel]);

    const handleSortModelChange = useCallback((model: GridSortModel) => {
        setSortModel(model);
    }, []);

    const handlePaginationModelChange = useCallback((params: GridPaginationModel) => {
        setPage(params.page);
        setPageSize(params.pageSize);
    }, []);

    const handleAggregateChange = useCallback((event: SelectChangeEvent<AggregateType>) => {
        setSelectedAggregate(event.target.value as AggregateType);
    }, []);

    const gridColumns: GridColDef[] = useMemo(() => {
        return [
            ...columns.map(col => ({
                field: col.key,
                headerName: col.label,
                flex: 1,
                sortable: true,
                filterable: true,
            })),
            {
                field: 'Total',
                headerName: 'Total',
                flex: 1,
                sortable: true,
                filterable: true,
            }
        ];
    }, [columns]);

    const grandTotal = useMemo(() => {
        const total: DataItem = { id: 'grand-total', 'Grand Total': 'Grand Total' };
        columns.forEach(col => {
            total[col.key] = pivotData.reduce((acc, item) => acc + (Number(item[col.key]) || 0), 0);
        });
        total['Total'] = pivotData.reduce((acc, item) => acc + (Number(item['Total']) || 0), 0);
        return total;
    }, [pivotData, columns]);

    const rowsWithGrandTotal = useMemo(() => {
        return [...sortedAndFilteredData, grandTotal];
    }, [sortedAndFilteredData, grandTotal]);

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            {heading && (
                <Typography variant="h6" component="h2">
                    {heading}
                </Typography>
            )}
            <Box sx={{ display: 'flex', gap: 2, flexGrow: 1 }}>
                <FormControl size="small" sx={{ flex: 1 }}>
                    <InputLabel>Aggregate</InputLabel>
                    <Select
                        value={selectedAggregate}
                        onChange={handleAggregateChange}
                        label="Aggregate"
                    >
                        <MenuItem value="sum">Sum</MenuItem>
                        <MenuItem value="average">Average</MenuItem>
                        <MenuItem value="count">Count</MenuItem>
                    </Select>
                </FormControl>
                <Autocomplete
                    multiple
                    options={availableColumns}
                    getOptionLabel={option => option.label}
                    value={columns}
                    onChange={(_, newValue) => {
                        const uniqueColumns = newValue.filter((col, index, self) =>
                            index === self.findIndex((c) => c.key === col.key)
                        );
                        setColumns(uniqueColumns);
                    }}
                    size="small"
                    renderInput={params => <TextField {...params} label="Columns" />}
                    sx={{ flex: 12 }}
                />
            </Box>

            <Box sx={{ flexGrow: 1, height: 600 }}>
                <DataGrid
                    rows={rowsWithGrandTotal}
                    columns={gridColumns}
                    pagination
                    pageSizeOptions={[100, 500, 1000]}
                    rowCount={sortedAndFilteredData.length}
                    paginationMode="server"
                    paginationModel={{ page, pageSize }}
                    onPaginationModelChange={handlePaginationModelChange}
                    sortingMode="server"
                    sortModel={sortModel}
                    onSortModelChange={handleSortModelChange}
                    getRowId={(row) => row.id}
                    disableRowSelectionOnClick
                    density="compact"
                    initialState={{
                        columns: {
                            columnVisibilityModel: {
                                Total: true,
                            },
                        },
                    }}
                    sx={{
                        '& .MuiDataGrid-row': {
                            '&.grand-total-row': {
                                fontWeight: 'bold',
                                backgroundColor: '#f0f0f0',
                            },
                        },
                    }}
                    getRowClassName={(params) => params.id === 'grand-total' ? 'grand-total-row' : ''}
                />
            </Box>
        </Box>
    );
};

export default React.memo(PivotTable);
